#include <math.h>
#include "../xmem.h"
#include "graphics.h"
#include "../config.h"
#include "ride.h"  // links to the basic drawing functions setPixel() and getPixel()


void drawLine(int x1, int y1, int x2, int y2, int c) {
    #define absL(a)  (((a) >= 0) ? (a) : -(a))
    int dx = absL(x2 - x1);
    int dy = absL(y2 - y1);
    int x = x1, y = y1;
    int addx = (x1 > x2) ? -1 : 1;
    int addy = (y1 > y2) ? -1 : 1;
    int i, p;
    if(dx >= dy) {
        p = 2 * dy - dx;
        for(i = 0; i <= dx; ++i) {
            setPixel(x, y, c);
            if(p < 0) {
                p += (2 * dy);
                x += addx;
            }
            else {
                p += (2 * dy) - (2 * dx);
                x += addx; y += addy;
            }
        }
    }
    else {
        p = 2 * dx - dy;
        for(i = 0; i <= dy; ++i) {
            setPixel(x, y, c);
            if(p < 0) {
                p += (2 * dx);
                y += addy;
            }
            else {
                p += (2 * dx) - (2 * dy);
                x += addx; y += addy;
            }
        }
    }
}


// draw a rectangular frame
void drawFrame(int x1, int y1, int x2, int y2, int c) {
    drawLine(x1, y1, x1, y2, c);
    drawLine(x1, y1, x2, y1, c);
    drawLine(x1, y2, x2, y2, c);
    drawLine(x2, y1, x2, y2, c);
}


// draw a solid rectangle
void drawRect(int x1, int y1, int x2, int y2, int c) {
    int t;
    if(y1 <= y2) for(t = y1; t <= y2; t++) drawLine(x1, t, x2, t, c);
    else for(t = y1; t >= y2; t--) drawLine(x1, t, x2, t, c);
}


void getRect(void *gbuffer, int x1, int y1, int x2, int y2) {
    int t, r;
    if(x2 < x1) { t = x2; x2 = x1; x1 = t; }
    if(y2 < y1) { t = y2; y2 = y1; y1 = t; }
    unsigned int *bhdr = (unsigned int *) gbuffer;
    *(bhdr++) = (unsigned int) (x2 - x1);
    *(bhdr++) = (unsigned int) (y2 - y1);
    unsigned char *buff = (unsigned char *) bhdr;
    char c = 0, b = 8;
    for(r = y1; r <= y2; r++)
        for(t = x1; t <= x2; t++) {
            c = (c << 1) + !getPixel(t, r);
            if(--b == 0) { *(buff++) = c; c = 0; b = 8; }
        }
    if(b) *(buff++) = c;
}


void putRect(void *gbuffer, int x1, int y1, int func) {
    int t, r, f;
    unsigned int *bhdr = (unsigned int *) gbuffer;
    int x2 = x1 + *(bhdr++);
    int y2 = y1 + *(bhdr++);
    unsigned char *buff = (unsigned char *) bhdr;
    char c = *(buff++), b = 8;
    for(r = y1; r <= y2; r++)
        for(t = x1; t <= x2; t++) {
            f = !(c & 0x80);
            if(func == 0) {}    // default "copy" type. No logical operation needed
            else if(func == 1) f |= getPixel(t, r);
            else if(func == 2) f ^= getPixel(t, r);
            else if(func == 3) f &= getPixel(t, r);
            else if(func == 4) f = !f;
            setPixel(t, r, f);
            if(--b) c <<= 1;
            else { c = *(buff++); b = 8; }
        }
}


void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int c) {
    int t, y, l, a, b;
    if(y1 > y2) {
        { t = x1; x1 = x2; x2 = t; }
        { t = y1; y1 = y2; y2 = t; }
    }
    if(y2 > y3) {
        { t = x2; x2 = x3; x3 = t; }
        { t = y2; y2 = y3; y3 = t; }
    }
    if(y1 > y2) {
        { t = x1; x1 = x2; x2 = t; }
        { t = y1; y1 = y2; y2 = t; }
    }
    if(y1 == y2 && y2 == y3) {  // handle the odd all-on-same-line case
        a = b = x1;
        if(x2 < a) a = x2;
        else if(x2 > b) b = x2;
        if(x3 < a) a = x3;
        else if(x3 > b) b = x3;
        drawRect(a, y1, (b - a + 1), y1, c);
        return;
    }
    int dx12 = x2 - x1;
    int dy12 = y2 - y1;
    int dx13 = x3 - x1;
    int dy13 = y3 - y1;
    int dx23 = x3 - x2;
    int dy23 = y3 - y2;
    long sa = 0;
    long sb = 0;
    if(y2 == y3) l = y2;
    else l = y2 - 1;
    for(y = y1; y <= l; y++) {
        a = x1 + sa / dy12;
        b = x1 + sb / dy13;
        sa += dx12;
        sb += dx13;
        // a = x1 + ((x2 - x1) * (y - y1)) / (y2 - y1);
        // b = x1 + ((x3 - x1) * (y - y1)) / (y3 - y1);
        if(a > b) { t = a; a = b; b = t; }
        drawRect(a, y, b, y, c);
    }
    sa = dx23 * (y - y2);
    sb = dx13 * (y - y1);
    for( ; y <= y3; y++) {
        a = x2 + sa / dy23;
        b = x1 + sb / dy13;
        sa += dx23;
        sb += dx13;
        // a = x2 + ((x3 - x2) * (y - y2)) / (y3 - y2);
        // b = x1 + ((x3 - x1) * (y - y1)) / (y3 - y1);
        if(a > b) { t = a; a = b; b = t; }
        drawRect(a, y, b, y, c);
    }
}


void drawCircle(int x, int y, int r, int c) {
	if(r >= 0) {	// solid circle
		int xt, yt, rr = r * r;
		for(yt = -r; yt <= r; yt++)
			for(xt = -r; xt <= r; xt++)
				if(((xt * xt) + (yt * yt)) <= rr) setPixel(x + xt, y + yt, c);
	}
	else {	// negative radius: only outline
		r = -r;
		int f = 1 - r;
		int ddF_x = 1, ddF_y = (-2 * r);
		int xt = 0, yt = r;
		setPixel(x, y + r, c);
		setPixel(x, y - r, c);
		setPixel(x + r, y, c);
		setPixel(x - r, y, c);
		while(xt < yt) {
			if(f >= 0) { yt--; ddF_y += 2; f += ddF_y; }
			else { xt++; ddF_x += 2; f += ddF_x; }
			setPixel(x + xt, y + yt, c);
			setPixel(x - xt, y + yt, c);
			setPixel(x + xt, y - yt, c);
			setPixel(x - xt, y - yt, c);
			setPixel(x + yt, y + xt, c);
			setPixel(x - yt, y + xt, c);
			setPixel(x + yt, y - xt, c);
			setPixel(x - yt, y - xt, c);
		}
	}
}


void drawEllipse(int x, int y, int rx, int ry, double tiltAngle, int c) {
	double C = cos(tiltAngle);
	double S_C = sin(tiltAngle);
	double xt, yt, xp, yp;
	if(rx > 0 && ry > 0) {  // solid ellipse
		for(yt = -ry; yt <= ry; yt++) {
			for(xt = -rx; xt <= rx; xt++) {
				double dx = (double) xt / (double) rx;
				double dy = (double) yt / (double) ry;
				double dd = ((dx * dx) + (dy * dy));
				if(dd <= 1.0) {
					xp =  C * xt + S_C * yt;
					yp = -S_C * xt + C * yt;
					setPixel(x + xp, y + yp, c);
				}
			}
		}
	}
	else if(rx < 0 && ry < 0) {	// both radiuses are negative: only outline
		rx = -rx; ry = -ry;
		double th = 0.0, st = 0.025;
		xt = rx * cos(th);
		yt = ry * sin(th);
		xp =  C * xt + S_C * yt;
		yp = -S_C * xt + C * yt;
		int xb = xp, yb = yp;
		for(th = st; th <= (2 * 3.14159265358979323846); th += st) {
			xt = rx * cos(th);
			yt = ry * sin(th);
			xp =  C * xt + S_C * yt;
			yp = -S_C * xt + C * yt;
			drawLine(x + xb, y + yb, x + xp, y + yp, c);
			xb = xp; yb = yp;
		}
	}
}


void drawSector(int x, int y, int rx, int ry, double tiltAngle, double startAngle, double endAngle, int c) {
    char outline = (rx < 0 && ry < 0);  // both radiuses are negative: only outline
    if(outline) { rx = -rx; ry = -ry; }
	if(rx <= 0 || ry <= 0 || startAngle == endAngle) return;
	if(startAngle > endAngle) {
        double v = startAngle;
		startAngle = endAngle;
		endAngle = v;
	}
    double C = cos(tiltAngle);
	double S_C = sin(tiltAngle);
	int xt, yt, xp, yp;
	double th, st = 0.015;
	xt = rx * cos(startAngle);
	yt = ry * sin(startAngle);
	xp =  C * xt + S_C * yt;
	yp = -S_C * xt + C * yt;
	drawLine(x, y, x + xp, y + yp, c);
	int xb = xp, yb = yp;
	for(th = startAngle; th <= endAngle; th += st) {
		xt = rx * cos(th);
		yt = ry * sin(th);
		xp =  C * xt + S_C * yt;
		yp = -S_C * xt + C * yt;
		drawLine(x + xb, y + yb, x + xp, y + yp, c);
		if(!outline) drawLine(x, y, x + xp, y + yp, c);     // make it solid
		xb = xp; yb = yp;
	}
	drawLine(x, y, x + xp, y + yp, c);
}


// variables needed for the flood fill stack
typedef struct { short x; short y; } fill_seed_t;
unsigned char *fstack;
unsigned short fsx, fsunits;


// NOTE: internal for the floodFill() function
// push coordinate seed
void pushSeed(short x, short y) {
	if(fsx >= fsunits) return;
	fill_seed_t *p = (fill_seed_t *) (fstack + (fsx++) * sizeof(fill_seed_t));
    p->x = (short) x;
    p->y = (short) y;
}


// NOTE: internal for the floodFill() function
// pop coordinate seed
char popSeed(int *x, int *y) {
	if(fsx <= 0) return 0;
	fill_seed_t *p = (fill_seed_t *) (fstack + (--fsx) * sizeof(fill_seed_t));
    *x = (int) p->x;
    *y = (int) p->y;
	return 1;
}


// main flood fill function
void floodFill(int x, int y, int c) {
	int b = getPixel(x, y); // get the base colour
	if(b == c) return;
	setPixel(x, y, ~b);
    int bb = getPixel(x, y);
    setPixel(x, y, b);
	if(bb == b) return;	// the display doesn't support reading
	fsx = 0;
	x_free((byte **) &fstack);  // make sure fstack[] is empty
	fsunits = (x_avail() / sizeof(fill_seed_t));    // grab as much as possible memory
    x_malloc((byte **) &fstack, (fsunits * sizeof(fill_seed_t)));
	if(!fstack) return;
	pushSeed(x, y);
	while(popSeed(&x, &y)) {
		setPixel(x, y, c);
		if(x > 0 && getPixel(x - 1, y) == b) pushSeed(x - 1, y);
		if(x < Hres && getPixel(x + 1, y) == b) pushSeed(x + 1, y);
		if(y > 0 && getPixel(x, y - 1) == b) pushSeed(x, y - 1);
		if(y < Vres && getPixel(x, y + 1) == b) pushSeed(x, y + 1);
	}
	x_free((unsigned char **) &fstack);
}


// NOTE: internal helper function for drawShape()
// get an integer number from the source; return 0 if unable to get any number
static int getnum(char **c) {
    int v = 0;
    char hexmode = 0, minus = 0;
    char *s = *c;
    while(*s == ' ') s++;   // skip any leading spaces
    if(*s == '-') { s++; minus = 1; }
    if(*s == '0' || *s == '+') s++;
    if(*s == 'x' || *s == 'X') { s++; hexmode = 1; }
	if((*s >= '0' && *s <= '9') || (hexmode && ((*s >= 'A' && *s <= 'F') || (*s >= 'a' && *s <= 'f')))) {
        if(hexmode) {
            do {
                if(*s >= '0' && *s <= '9') v = (v << 4) + (*s - '0');
                else if(*s >= 'A' && *s <= 'F') v = (v << 4) + (*s - 'A');
                else if(*s >= 'a' && *s <= 'f') v = (v << 4) + (*s - 'a');
                else break;
            } while(++s);
        }
        else {
            while(*s >= '0' && *s <= '9') {
                v = (v * 10) + (*s - '0');
                s++;
            }
        }
	}
	*c = s;
    return (minus ? -v : v);
}


// draw a shape defined as a text string
// commands:
// M [stX],[stY] - move to a new point with relative coordinates
// C [col]       - set new drawing colour and enable draw when moving
// D             - enable draw when moving
// N             - disable draw when moving
// F             - flood fill
void drawShape(int x, int y, double tiltAngle, char *def) {
	if(!def || *def == 0) return;
    char draw = 1;
	int xt, yt, vx, vy, col = 0;
    double C = cos(tiltAngle);
    double S_C = sin(tiltAngle);
	while(*def) {
        if(*def == ' ') def++;
        else if(*def == 'C' || *def == 'c') {   // set drawing colour and enable draw
            def++;
			col = getnum(&def);
            draw = 1;
		}
        else if(*def == 'D' || *def == 'd') {   // set draw
			def++;
			draw = 1;
		}
        else if(*def == 'N' || *def == 'n') {   // set no draw
			def++;
			draw = 0;
		}
		else if(*def == 'F' || *def == 'f') {   // flood fill an area starting with seed from the current pixel
			def++;
			floodFill(x, y, col);
		}
		else if(*def == 'M' || *def == 'm') {
            def++;
			vx = getnum(&def);  /* horizontal displacement */
			while(*def == ' ') def++;
			if(*def != ',') continue;   // ignore command with insufficient parameters
            def++;
			vy = getnum(&def);  /* vertical displacement */
            xt =  C * vx + S_C * vy;
            yt = -S_C * vx + C * vy;
            if(draw) drawLine(x, y, x + xt, y + yt, col);
            x += xt; y += yt;
		}
		else break;
	}
}


void drawChar(int ch) {
    static unsigned short lastW = 0;    // width of the last graphically printed character including the right blanking pixels
    static unsigned char cursorInv = 0; // indicates if the cursor is currently inverting
	unsigned short c, th = (font->header.blankT + font->header.height + font->header.blankB);
    if(fontScale < 1) fontScale = 1;
	if(ch == 0 || cursorInv) {  // character 0 is only displaying a virtual cursor
        cursorInv = !cursorInv;
		drawRect(posX, posY, (posX + fontScale), (posY + (fontScale * th) - 1), COL_INVERT);
		if(ch == 0) return;
	}
	if(font->header.height == 0 || ch < font->header.start || ch >= (font->header.start + font->header.characters)) return;
	if((enable_flags & FLAG_NO_CTRL) == 0) {	// control characters are enabled only if (no_control_characters) is 0
		if(ch == '\r') { posX = 0; return; }
		else if(ch == '\n') {
			posY += (fontScale * th);
			if(posY + (fontScale * th) > Vres) {
                if((enable_flags & FLAG_NO_SCROLL) == 0) scrollUp((fontScale * th), fontBcol);
                posY -= (fontScale * th);
            }
			return;
		}
		else if(ch == '\t') {
			for(c = 0; c < settings.tab_width; c++) drawChar(' ');
			return;
		}
		else if(ch == '\b') {
			if(posX >= (fontScale * lastW)) posX -= (fontScale * lastW); else posX = 0;
			drawRect(posX, posY, (posX + lastW - 1), (posY + (fontScale * th) - 1), fontBcol);
			return;
		}
	}
	int i, j, w, x, y, y0;
	const unsigned char *fcp, *fc = font->definitions;
	ch -= font->header.start;
	if(font->header.width == 0) {		// variable width fonts
		while(ch--) fc += (1 + *fc);	// skip the preceding characters
		w = *(fc++);	// get the width for this character
	}
	else {	// fixed width fonts
		fc += (ch * font->header.width);
		w = font->header.width;
	}
	if((posX + (fontScale * (font->header.blankL + w + font->header.blankR))) > Hres) {
		posX = 0;
		posY += (fontScale * th);
	}
	if(posY + (fontScale * th) > Vres) {
        if((enable_flags & FLAG_NO_SCROLL) == 0) scrollUp((fontScale * th), fontBcol);
        posY -= (fontScale * th);
    }
	x = posX;
	y0 = posY;
	if(font->header.blankL) {
		drawRect(x, y0, (x + (fontScale * font->header.blankL) - 1), (y0 + (fontScale * th) - 1), fontBcol);
		x += (fontScale * font->header.blankL);	// adding blanks to the left
	}
	posX = x;	// this is needed in order to ignore the blank columns when considering smoothing
	for(i = 0; i < w; i++, x += fontScale) {	// columns
		y = posY;
		for(j = 0; j < font->header.blankT; j++) {	// adding blanks to the top
			drawRect(x, y, (x + fontScale - 1), (y + fontScale - 1), fontBcol);
			y += fontScale;
		}
		drawRect(x, y, (x + fontScale - 1), (y + (font->header.height * fontScale) - 1), fontBcol);
		unsigned long pz = 0;
		unsigned long z = 0;
		for(c = 0, j = 0; j < font->header.height; c++, j++, z >>= 1, pz >>= 1) {	// lines
			if((c & 7) == 0) {
				z = ((unsigned short) *(fc++)) << 1;
				if(x > posX) {
					pz = 2 + ((font->header.height - 1) / 8);
					fcp = (unsigned char *) (fc - pz);
					pz = (unsigned short) *fcp;
					if(font->header.height > 8) pz += ((unsigned short) *(fcp + 1) << 8);
					pz <<= 1;
				}
			}
			if(z & BIT(1)) {
				drawRect(x, y, (x + fontScale - 1), (y + fontScale - 1), fontFcol);
				if(fontScale > 1 && fontFcol >= 0) {    // font smoothing (doesn't work with the special colours)
					if((j > 0) && (pz & !(pz & BIT(1)) && BIT(0)) && !(z & BIT(0))) {
						drawTriangle(x, y, (x + fontScale - 1), y, x, (y - fontScale + 1), fontFcol);
						drawTriangle(x, y, (x - fontScale + 1), y, x, (y + fontScale - 1), fontFcol);
					}
					if((j < (font->header.height - 1)) && !(pz & BIT(1)) && (pz & BIT(2)) && !(z & BIT(2))) {
						drawTriangle(x, (y + fontScale - 1), (x - fontScale + 1), (y + fontScale - 1), x, y, fontFcol);
						drawTriangle(x, (y + fontScale - 1), (x + fontScale - 1), (y + fontScale - 1), x, (y + 2 * fontScale - 2), fontFcol);
					}
				}
			}
			y += fontScale;
		}
		for(j = 0; j < font->header.blankB; j++) {	// adding blanks to the bottom
			drawRect(x, y, (x + fontScale - 1), (y + fontScale - 1), fontBcol);
			y += fontScale;
		}
	}
	if(font->header.blankR) {
		drawRect(x, y0, (x + (fontScale * font->header.blankR) - 1), (y0 + (fontScale * th) - 1), fontBcol);
		x += (fontScale * font->header.blankR);	// adding blanks to the right
	}
	posX = x;
	lastW = font->header.blankL + w + font->header.blankR;
}


// SYSTEM FONT ==================================================================================

// standard ASCII font 5x8 pixels (drawn in 6x10 pixels box)
__attribute__ ((space(prog)))
const font_t sysFont0508 = { {
    1,      // code of the first character in the font
    255,    // 255 characters in this font (ASCII codes 0x01 ... 0xFF)
    5,      // fixed with 5 columns in every character
    8,      // 8 rows in every character
    1,      // blank columns on the left side of every character
    0,      // blank columns on the right side of every character
    1,      // blank rows on the top side of every character
    1,      // blank rows on the bottom side of every character
    "ELLO System Font"
    }, {
        0x3E, 0x5B, 0x5F, 0x5B, 0x3E,    // 0x01
        0x3E, 0x55, 0x51, 0x55, 0x3E,    // 0x02
        0x1C, 0x3E, 0x7C, 0x3E, 0x1C,    // 0x03
        0x18, 0x3C, 0x7E, 0x3C, 0x18,    // 0x04
        0x1C, 0x57, 0x7D, 0x57, 0x1C,    // 0x05
        0x1C, 0x5E, 0x7F, 0x5E, 0x1C,    // 0x06
        0x00, 0x18, 0x3C, 0x18, 0x00,    // 0x07
        0xFF, 0xE7, 0xC3, 0xE7, 0xFF,    // 0x08
        0x00, 0x18, 0x24, 0x18, 0x00,    // 0x09
        0xFF, 0xE7, 0xDB, 0xE7, 0xFF,    // 0x0A
        0x30, 0x48, 0x3A, 0x06, 0x0E,    // 0x0B
        0x26, 0x29, 0x79, 0x29, 0x26,    // 0x0C
        0x00, 0x60, 0x7F, 0x01, 0x06,    // 0x0D
        0x60, 0x7E, 0x05, 0x35, 0x3F,    // 0x0E
        0x5A, 0x3C, 0xE7, 0x3C, 0x5A,    // 0x0F
        0x7F, 0x3E, 0x1C, 0x1C, 0x08,    // 0x10
        0x08, 0x1C, 0x1C, 0x3E, 0x7F,    // 0x11
        0x14, 0x22, 0x7F, 0x22, 0x14,    // 0x12
        0x5F, 0x5F, 0x00, 0x5F, 0x5F,    // 0x13
        0x06, 0x09, 0x7F, 0x01, 0x7F,    // 0x14
        0x00, 0x66, 0x89, 0x95, 0x6A,    // 0x15
        0x60, 0x60, 0x60, 0x60, 0x60,    // 0x16
        0x94, 0xA2, 0xFF, 0xA2, 0x94,    // 0x17
        0x08, 0x04, 0x7E, 0x04, 0x08,    // 0x18
        0x10, 0x20, 0x7E, 0x20, 0x10,    // 0x19
        0x08, 0x08, 0x2A, 0x1C, 0x08,    // 0x1A
        0x08, 0x1C, 0x2A, 0x08, 0x08,    // 0x1B
        0x1E, 0x10, 0x10, 0x10, 0x10,    // 0x1C
        0x0C, 0x1E, 0x0C, 0x1E, 0x0C,    // 0x1D
        0x30, 0x38, 0x3C, 0x38, 0x30,    // 0x1E
        0x0C, 0x1C, 0x3C, 0x1C, 0x0C,    // 0x1F
        0x00, 0x00, 0x00, 0x00, 0x00,    // 0x20
        0x00, 0x5F, 0x5F, 0x00, 0x00,    // 0x21
        0x00, 0x07, 0x00, 0x07, 0x00,    // 0x22
        0x14, 0x7F, 0x14, 0x7F, 0x14,    // 0x23
        0x24, 0x2A, 0x7F, 0x2A, 0x12,    // 0x24
        0x23, 0x13, 0x08, 0x64, 0x62,    // 0x25
        0x36, 0x49, 0x56, 0x20, 0x50,    // 0x26
        0x00, 0x08, 0x07, 0x03, 0x00,    // 0x27
        0x00, 0x1C, 0x22, 0x41, 0x00,    // 0x28
        0x00, 0x41, 0x22, 0x1C, 0x00,    // 0x29
        0x2A, 0x1C, 0x7F, 0x1C, 0x2A,    // 0x2A
        0x08, 0x08, 0x3E, 0x08, 0x08,    // 0x2B
        0x00, 0x80, 0x70, 0x30, 0x00,    // 0x2C
        0x08, 0x08, 0x08, 0x08, 0x08,    // 0x2D
        0x00, 0x00, 0x60, 0x60, 0x00,    // 0x2E
        0x20, 0x10, 0x08, 0x04, 0x02,    // 0x2F
        0x3E, 0x51, 0x49, 0x45, 0x3E,    // 0x30
        0x00, 0x42, 0x7F, 0x40, 0x00,    // 0x31
        0x72, 0x49, 0x49, 0x49, 0x46,    // 0x32
        0x21, 0x41, 0x49, 0x4D, 0x33,    // 0x33
        0x18, 0x14, 0x12, 0x7F, 0x10,    // 0x34
        0x27, 0x45, 0x45, 0x45, 0x39,    // 0x35
        0x3C, 0x4A, 0x49, 0x49, 0x31,    // 0x36
        0x41, 0x21, 0x11, 0x09, 0x07,    // 0x37
        0x36, 0x49, 0x49, 0x49, 0x36,    // 0x38
        0x46, 0x49, 0x49, 0x29, 0x1E,    // 0x39
        0x00, 0x36, 0x36, 0x00, 0x00,    // 0x3A
        0x00, 0x80, 0x76, 0x36, 0x00,    // 0x3B
        0x00, 0x08, 0x14, 0x22, 0x41,    // 0x3C
        0x14, 0x14, 0x14, 0x14, 0x14,    // 0x3D
        0x00, 0x41, 0x22, 0x14, 0x08,    // 0x3E
        0x02, 0x01, 0x59, 0x09, 0x06,    // 0x3F
        0x3E, 0x41, 0x5D, 0x59, 0x4E,    // 0x40
        0x7C, 0x12, 0x11, 0x12, 0x7C,    // 0x41
        0x7F, 0x49, 0x49, 0x49, 0x36,    // 0x42
        0x3E, 0x41, 0x41, 0x41, 0x22,    // 0x43
        0x7F, 0x41, 0x41, 0x41, 0x3E,    // 0x44
        0x7F, 0x49, 0x49, 0x49, 0x41,    // 0x45
        0x7F, 0x09, 0x09, 0x09, 0x01,    // 0x46
        0x3E, 0x41, 0x41, 0x51, 0x73,    // 0x47
        0x7F, 0x08, 0x08, 0x08, 0x7F,    // 0x48
        0x00, 0x41, 0x7F, 0x41, 0x00,    // 0x49
        0x20, 0x40, 0x41, 0x3F, 0x01,    // 0x4A
        0x7F, 0x08, 0x14, 0x22, 0x41,    // 0x4B
        0x7F, 0x40, 0x40, 0x40, 0x40,    // 0x4C
        0x7F, 0x02, 0x1C, 0x02, 0x7F,    // 0x4D
        0x7F, 0x04, 0x08, 0x10, 0x7F,    // 0x4E
        0x3E, 0x41, 0x41, 0x41, 0x3E,    // 0x4F
        0x7F, 0x09, 0x09, 0x09, 0x06,    // 0x50
        0x3E, 0x41, 0x51, 0x21, 0x5E,    // 0x51
        0x7F, 0x09, 0x19, 0x29, 0x46,    // 0x52
        0x26, 0x49, 0x49, 0x49, 0x32,    // 0x53
        0x03, 0x01, 0x7F, 0x01, 0x03,    // 0x54
        0x3F, 0x40, 0x40, 0x40, 0x3F,    // 0x55
        0x1F, 0x20, 0x40, 0x20, 0x1F,    // 0x56
        0x3F, 0x40, 0x38, 0x40, 0x3F,    // 0x57
        0x63, 0x14, 0x08, 0x14, 0x63,    // 0x58
        0x03, 0x04, 0x78, 0x04, 0x03,    // 0x59
        0x61, 0x59, 0x49, 0x4D, 0x43,    // 0x5A
        0x00, 0x7F, 0x41, 0x41, 0x41,    // 0x5B
        0x02, 0x04, 0x08, 0x10, 0x20,    // 0x5C
        0x00, 0x41, 0x41, 0x41, 0x7F,    // 0x5D
        0x04, 0x02, 0x01, 0x02, 0x04,    // 0x5E
        0x40, 0x40, 0x40, 0x40, 0x40,    // 0x5F
        0x00, 0x03, 0x07, 0x08, 0x00,    // 0x60
        0x20, 0x54, 0x54, 0x78, 0x40,    // 0x61
        0x7F, 0x28, 0x44, 0x44, 0x38,    // 0x62
        0x38, 0x44, 0x44, 0x44, 0x28,    // 0x63
        0x38, 0x44, 0x44, 0x28, 0x7F,    // 0x64
        0x38, 0x54, 0x54, 0x54, 0x18,    // 0x65
        0x00, 0x08, 0x7E, 0x09, 0x02,    // 0x66
        0x18, 0xA4, 0xA4, 0x9C, 0x78,    // 0x67
        0x7F, 0x08, 0x04, 0x04, 0x78,    // 0x68
        0x00, 0x44, 0x7D, 0x40, 0x00,    // 0x69
        0x20, 0x40, 0x40, 0x3D, 0x00,    // 0x6A
        0x7F, 0x10, 0x28, 0x44, 0x00,    // 0x6B
        0x00, 0x41, 0x7F, 0x40, 0x00,    // 0x6C
        0x7C, 0x04, 0x78, 0x04, 0x78,    // 0x6D
        0x7C, 0x08, 0x04, 0x04, 0x78,    // 0x6E
        0x38, 0x44, 0x44, 0x44, 0x38,    // 0x6F
        0xFC, 0x18, 0x24, 0x24, 0x18,    // 0x70
        0x18, 0x24, 0x24, 0x18, 0xFC,    // 0x71
        0x7C, 0x08, 0x04, 0x04, 0x08,    // 0x72
        0x48, 0x54, 0x54, 0x54, 0x24,    // 0x73
        0x04, 0x04, 0x3F, 0x44, 0x24,    // 0x74
        0x3C, 0x40, 0x40, 0x20, 0x7C,    // 0x75
        0x1C, 0x20, 0x40, 0x20, 0x1C,    // 0x76
        0x3C, 0x40, 0x30, 0x40, 0x3C,    // 0x77
        0x44, 0x28, 0x10, 0x28, 0x44,    // 0x78
        0x4C, 0x90, 0x90, 0x90, 0x7C,    // 0x79
        0x44, 0x64, 0x54, 0x4C, 0x44,    // 0x7A
        0x00, 0x08, 0x36, 0x41, 0x00,    // 0x7B
        0x00, 0x00, 0x77, 0x00, 0x00,    // 0x7C
        0x00, 0x41, 0x36, 0x08, 0x00,    // 0x7D
        0x02, 0x01, 0x02, 0x04, 0x02,    // 0x7E
        0x3C, 0x26, 0x23, 0x26, 0x3C,    // 0x7F
        0x1E, 0xA1, 0xA1, 0x61, 0x12,    // 0x80
        0x38, 0x42, 0x40, 0x22, 0x78,    // 0x81
        0x38, 0x54, 0x54, 0x55, 0x59,    // 0x82
        0x20, 0x56, 0x55, 0x7A, 0x40,    // 0x83
        0x20, 0x55, 0x54, 0x79, 0x40,    // 0x84
        0x21, 0x55, 0x54, 0x78, 0x40,    // 0x85
        0x20, 0x54, 0x55, 0x79, 0x40,    // 0x86
        0x0C, 0x1E, 0x52, 0x72, 0x12,    // 0x87
        0x38, 0x56, 0x55, 0x56, 0x58,    // 0x88
        0x38, 0x55, 0x54, 0x55, 0x58,    // 0x89
        0x39, 0x55, 0x54, 0x54, 0x58,    // 0x8A
        0x00, 0x00, 0x45, 0x7C, 0x41,    // 0x8B
        0x00, 0x00, 0x4A, 0x79, 0x42,    // 0x8C
        0x00, 0x01, 0x45, 0x7C, 0x40,    // 0x8D
        0x7C, 0x13, 0x12, 0x13, 0x7C,    // 0x8E
        0x78, 0x16, 0x15, 0x16, 0x78,    // 0x8F
        0xFE, 0x92, 0x92, 0x91, 0x81,    // 0x90
        0x20, 0x54, 0x54, 0x7C, 0x54,    // 0x91
        0x7C, 0x0A, 0x09, 0x7F, 0x49,    // 0x92
        0x30, 0x4A, 0x49, 0x4A, 0x30,    // 0x93
        0x38, 0x45, 0x44, 0x45, 0x38,    // 0x94
        0x32, 0x4A, 0x48, 0x48, 0x30,    // 0x95
        0x38, 0x42, 0x41, 0x22, 0x78,    // 0x96
        0x3A, 0x42, 0x40, 0x20, 0x78,    // 0x97
        0x00, 0x9D, 0xA0, 0xA0, 0x7D,    // 0x98
        0x3C, 0x43, 0x42, 0x43, 0x3C,    // 0x99
        0x3C, 0x41, 0x40, 0x41, 0x3C,    // 0x9A
        0x3C, 0x24, 0xFF, 0x24, 0x24,    // 0x9B
        0x48, 0x7E, 0x49, 0x43, 0x66,    // 0x9C
        0x51, 0x52, 0xFC, 0x52, 0x51,    // 0x9D
        0x28, 0x7C, 0xAA, 0x82, 0x44,    // 0x9E
        0xC0, 0x88, 0x7E, 0x09, 0x03,    // 0x9F
        0x20, 0x54, 0x54, 0x79, 0x41,    // 0xA0
        0x00, 0x00, 0x44, 0x7D, 0x41,    // 0xA1
        0x30, 0x48, 0x48, 0x4A, 0x32,    // 0xA2
        0x38, 0x40, 0x40, 0x22, 0x7A,    // 0xA3
        0x00, 0x7A, 0x09, 0x0A, 0x71,    // 0xA4
        0x7D, 0x09, 0x11, 0x21, 0x7D,    // 0xA5
        0x06, 0x09, 0x09, 0x0F, 0x08,    // 0xA6
        0x06, 0x09, 0x09, 0x09, 0x06,    // 0xA7
        0x30, 0x48, 0x4D, 0x40, 0x20,    // 0xA8
        0x38, 0x08, 0x08, 0x08, 0x08,    // 0xA9
        0x08, 0x08, 0x08, 0x08, 0x38,    // 0xAA
        0x2F, 0x10, 0xC8, 0xAC, 0xBA,    // 0xAB
        0x2F, 0x10, 0x28, 0x34, 0xFA,    // 0xAC
        0x00, 0x00, 0x7D, 0x7D, 0x00,    // 0xAD
        0x08, 0x14, 0x2A, 0x14, 0x22,    // 0xAE
        0x22, 0x14, 0x2A, 0x14, 0x08,    // 0xAF
        0x55, 0x00, 0x55, 0x00, 0x55,    // 0xB0
        0xAA, 0x55, 0xAA, 0x55, 0xAA,    // 0xB1
        0xFF, 0x55, 0xFF, 0x55, 0xFF,    // 0xB2
        0x00, 0x00, 0xFF, 0x00, 0x00,    // 0xB3
        0x10, 0x10, 0xFF, 0x00, 0x00,    // 0xB4
        0x14, 0xFF, 0x00, 0xFF, 0x00,    // 0xB5
        0x10, 0xFF, 0x00, 0xFF, 0x00,    // 0xB6
        0x10, 0xF0, 0x10, 0xF0, 0x00,    // 0xB7
        0x14, 0x14, 0xFC, 0x00, 0x00,    // 0xB8
        0x14, 0xF7, 0x00, 0xFF, 0x00,    // 0xB9
        0x00, 0xFF, 0x00, 0xFF, 0x00,    // 0xBA
        0x14, 0xF4, 0x04, 0xFC, 0x00,    // 0xBB
        0x14, 0x17, 0x10, 0x1F, 0x00,    // 0xBC
        0x10, 0x1F, 0x10, 0x1F, 0x00,    // 0xBD
        0x14, 0x14, 0x1F, 0x00, 0x00,    // 0xBE
        0x10, 0x10, 0xF0, 0x00, 0x00,    // 0xBF
        0x00, 0x00, 0x1F, 0x10, 0x10,    // 0xC0
        0x10, 0x10, 0x1F, 0x10, 0x10,    // 0xC1
        0x10, 0x10, 0xF0, 0x10, 0x10,    // 0xC2
        0x00, 0x00, 0xFF, 0x10, 0x10,    // 0xC3
        0x10, 0x10, 0x10, 0x10, 0x10,    // 0xC4
        0x10, 0x10, 0xFF, 0x10, 0x10,    // 0xC5
        0x00, 0x00, 0xFF, 0x14, 0x14,    // 0xC6
        0x00, 0xFF, 0x00, 0xFF, 0x10,    // 0xC7
        0x00, 0x1F, 0x10, 0x17, 0x14,    // 0xC8
        0x00, 0xFC, 0x04, 0xF4, 0x14,    // 0xC9
        0x14, 0x17, 0x10, 0x17, 0x14,    // 0xCA
        0x14, 0xF4, 0x04, 0xF4, 0x14,    // 0xCB
        0x00, 0xFF, 0x00, 0xF7, 0x14,    // 0xCC
        0x14, 0x14, 0x14, 0x14, 0x14,    // 0xCD
        0x14, 0xF7, 0x00, 0xF7, 0x14,    // 0xCE
        0x14, 0x14, 0x17, 0x14, 0x14,    // 0xCF
        0x10, 0x1F, 0x10, 0x1F, 0x00,    // 0xD0
        0x14, 0x14, 0xF4, 0x14, 0x14,    // 0xD1
        0x10, 0xF0, 0x10, 0xF0, 0x00,    // 0xD2
        0x00, 0x1F, 0x10, 0x1F, 0x10,    // 0xD3
        0x00, 0x00, 0x1F, 0x14, 0x14,    // 0xD4
        0x00, 0x00, 0xFC, 0x14, 0x14,    // 0xD5
        0x00, 0xF0, 0x10, 0xF0, 0x10,    // 0xD6
        0x10, 0xFF, 0x00, 0xFF, 0x00,    // 0xD7
        0x14, 0xFF, 0x00, 0xFF, 0x00,    // 0xD8
        0x10, 0x10, 0x1F, 0x00, 0x00,    // 0xD9
        0x00, 0x00, 0xF0, 0x10, 0x10,    // 0xDA
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    // 0xDB
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0,    // 0xDC
        0xFF, 0xFF, 0xFF, 0x00, 0x00,    // 0xDD
        0x00, 0x00, 0xFF, 0xFF, 0xFF,    // 0xDE
        0x0F, 0x0F, 0x0F, 0x0F, 0x0F,    // 0xDF
        0x38, 0x44, 0x44, 0x38, 0x44,    // 0xE0
        0xFC, 0x4A, 0x4A, 0x4A, 0x34,    // 0xE1
        0x7E, 0x02, 0x02, 0x06, 0x06,    // 0xE2
        0x02, 0x7E, 0x02, 0x7E, 0x02,    // 0xE3
        0x63, 0x55, 0x49, 0x41, 0x63,    // 0xE4
        0x38, 0x44, 0x44, 0x3C, 0x04,    // 0xE5
        0x40, 0x7E, 0x20, 0x1E, 0x20,    // 0xE6
        0x06, 0x02, 0x7E, 0x02, 0x02,    // 0xE7
        0x18, 0xA5, 0xFF, 0xA5, 0x18,    // 0xE8
        0x3C, 0x52, 0x4A, 0x52, 0x3C,    // 0xE9
        0x4C, 0x72, 0x02, 0x72, 0x4C,    // 0xEA
        0x00, 0x3A, 0x45, 0x45, 0x39,    // 0xEB
        0x1C, 0x22, 0xF8, 0x24, 0x18,    // 0xEC
        0xBC, 0x62, 0x5A, 0x46, 0x3D,    // 0xED
        0x00, 0x28, 0x54, 0x44, 0x28,    // 0xEE
        0x7E, 0x01, 0x01, 0x01, 0x7E,    // 0xEF
        0x2A, 0x2A, 0x2A, 0x2A, 0x2A,    // 0xF0
        0x44, 0x44, 0x5F, 0x44, 0x44,    // 0xF1
        0x40, 0x51, 0x4A, 0x44, 0x40,    // 0xF2
        0x40, 0x44, 0x4A, 0x51, 0x40,    // 0xF3
        0x00, 0x00, 0xFF, 0x01, 0x03,    // 0xF4
        0xE0, 0x80, 0xFF, 0x00, 0x00,    // 0xF5
        0x08, 0x08, 0x6B, 0x6B, 0x08,    // 0xF6
        0x36, 0x12, 0x36, 0x24, 0x36,    // 0xF7
        0x06, 0x0F, 0x09, 0x0F, 0x06,    // 0xF8
        0x00, 0x00, 0x18, 0x18, 0x00,    // 0xF9
        0x00, 0x00, 0x10, 0x10, 0x00,    // 0xFA
        0x30, 0x40, 0xFF, 0x01, 0x01,    // 0xFB
        0x00, 0x1F, 0x01, 0x01, 0x1E,    // 0xFC
        0x00, 0x19, 0x1D, 0x17, 0x12,    // 0xFD
        0x00, 0x3C, 0x3C, 0x3C, 0x3C,    // 0xFE
        0x00, 0x00, 0x00, 0x00, 0x00     // 0xFF
    }
};
